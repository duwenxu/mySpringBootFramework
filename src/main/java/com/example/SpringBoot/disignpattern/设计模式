1. UML类图中的关系：
        泛化关系(generalization):表现为 继承非抽象类    is a的关系
                                类的继承结构表现在UML中为：泛化(generalize)与实现(realize)
        实现关系(realize)：表现为 继承抽象类或实现接口
        聚合关系（aggregation）：表示 实体对象之间的关系，整体由部分构成    整体不存在了，部分依然存在(非强依赖)
        组合关系（composition）: 表示 实体对象之间的关系，整体由部分构成    整体不存在了，则部分也不存在(强依赖关系)
        关联关系（association）: 不同对象之间的一种静态关系，通常表现为 成员变量的形式
        依赖关系（dependency）: 表示一个对象在 运行期间 会用到另一个对象的关系
                               1.是一种临时性的关系    2.代码中表现为 类构造或其它方法的传入参数
2. 创建型模式：
        1. 简单工厂模式（静态工厂）：属于 类创建型模式
               a.角色     Factory：工厂角色                 工厂角色负责实现创建所有实例的内部逻辑
                          Product：抽象产品角色             抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口
                          ConcreteProduct：具体产品角色     具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例
               b.要点     当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节
               c.优点     对象的创建和对象的使用分离，将对象的创建交给专门的工厂类负责
                 缺点     工厂类不够灵活，增加新的具体产品需要修改工厂类的判断逻辑代码，而且产品较多时，工厂方法代码将会非常复杂
               d.使用场景   工厂类负责创建的对象比较少；客户端只知道传入工厂类的参数，对于如何创建对象不关心
        2. 工厂方法模式（工厂模式、虚拟其构造模式、多态工厂）：属于 类创建型模式
                a.角色    Product：抽象产品
                          ConcreteProduct：具体产品
                          Factory：抽象工厂                  定义创建产品对象的公共接口   将具体的产品类实例化操作延迟到工厂子类中完成
                          ConcreteFactory：具体工厂          负责生成具体的产品对象
                b.要点     在简单工厂模式的基础上对工厂类进行了多态化，所有的具体工厂类都需要实现抽象工厂类。
                           工厂角色和产品角色的多态性设计是工厂方法模式的关键
                c.优点     相比于简单工厂模式，加入新产品时只需要添加一个具体工厂和相对应的具体产品即可，而无需修改已有类。
                  缺点     添加新产品时，类的数量成对增加，一定程度上增加了系统的复杂性
                d.使用场景  将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定
        3.抽象工厂模式：（所有形式的工厂模式中最为抽象和最具一般性的一种形态）属于 对象创建型模式
                a.角色      Product：抽象产品                 为每种产品声明接口，在抽象产品中定义了产品的抽象业务方法
                           ConcreteProduct：具体产品          定义具体工厂生产的具体产品对象，实现抽象产品接口中定义的业务方法
                           Factory：抽象工厂                  声明生成抽象产品的方法
                           ConcreteFactory：具体工厂          实现了抽象工厂声明的生成抽象产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中
                b.要点     相比于工厂模式，增加了多个产品等级结构。
                           抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构
                                   产品等级结构：产品的继承结构    比如：抽象产品类---->具体产品类
                                   产品族：在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品
                c.优点      每次可以通过具体工厂类创建一个产品族中的多个对象，增加新的具体工厂和产品族很方便
                  缺点      增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类，对“开闭原则”的支持呈现倾斜性
                d.使用场景： 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节；系统中有多于一个的产品族，而每次只使用其中某一产品族
                            属于同一个产品族的产品将在一起使用；系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现
        4.建造者模式
                1.经典的Builder模式
                    4个角色：
                            Product：产品实例
                                    被构建的复杂对象，包含多个组成部件
                            Builder：定义了构建 Product 的抽象步骤 和 获取最终产品的方法 getProduct()
                                    抽象建造者为创建一个产品对象的各个部件指定抽象接口
                            ConcreteBuilder：Builder的具体实现类
                                    具体建造者实现了抽象建造者接口，实现各个部件的构造和装配方法，定义并明确它所创建的复杂对象，也可以提供一个方法返回创建好的复杂产品对象
                            Director：决定如何构建最终产品的算法. 包含一个负责组装的方法void Construct(Builder builder)，
                                      在这个方法中通过调用builder的方法，就可以设置builder，等设置完成后，就可以通过builder的 getProduct() 方法获得最终的产品
                                      该类的作用主要有两个：一方面它隔离了客户与生产过程；另一方面它负责控制产品的生成过程
                2.链式调用
                    builder模式的变种：
                            a. 省略了director 这个角色，将构建算法交给了client端
                            b. 将builder 写到了要构建的产品类里面，最后采用了链式调用
        5.prototype原型模式
                a. 角色：
                            抽象原型（Prototype）角色：规定了具体原型对象必须实现的接口（如果要提供深拷贝，则必须具有实现clone的规定）
                            具体原型（ConcretePrototype）：从抽象原型派生而来，是客户程序使用的对象，即被复制的对象，需要实现抽象原型角色所要求的接口
                b. 要点：
                            使用原型实例指定创建对象的种类，并且通过拷贝原型对象创建新的对象
                            相比于使用new创建新对象减少了构造函数的执行时间
                            实现方式：
                                    1. 实现 Cloneable 接口：Cloneable 接口与序列化接口的作用类似，它只是告诉虚拟机可以安全地在实现了这个接口的类上使用 clone() 方法。
                                    在 JVM 中，只有实现了 Cloneable 接口的类才可以被拷贝，否则会抛出 CloneNotSupportedException 异常
                                    2. 重写 Object 类中的 clone() 方法：在 Java 中，所有类的父类都是 Object 类，而 Object 类中有一个 clone() 方法，作用是返回对象的一个拷贝
                                    3. 在重写的 clone() 方法中调用 super.clone()：默认情况下，类不具备复制对象的能力，需要调用 super.clone() 来实现。
                            tips: 深拷贝与浅拷贝
                                    浅拷贝：只是拷贝对像本身，对象的所有变量都含有与原对象相同的值，但其所引用的对象仍然是原来的引用
                                    深拷贝：将要拷贝的对象所引用的对象也都拷贝了一次，彻底的拷贝
        6.对象池模式
                对于创建成本高的对象，采用object poll 对对象进行循环使用
                复用池中对象,消除创建对象、回收对象 所产生的内存开销、cpu开销以及(若跨网络)产生的网络开销。
                常见： 线程池、连接池等
                a. 角色：
                            ObjectPoll：对象池，用于保存和管理资源，持有对象并提供取/还等方法
                            object: 特定的资源类
                            client: 使用者类。   获取资源---使用----归还

3.行为型模式
        1. 观察者模式：定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新    对象行为型模式
                a.角色：
                        abstractSubject: 抽象主题(抽象被观察者)
                                        保持观察者的列表，有权增删观察者，发生变化时通知观察者
                        concreteSubject: 具体被观察者   实现具体的改变，并在发生改变时 通知具体的观察者
                        abstractObserver: 抽象观察者  定义update()接口，即收到主题通知后的操作
                        concreteObserver: 具体观察者  实现update()接口，保持与主题的改变相符合的状态
                b.推模型和拉模型
                        推模型： push 由subject主题对象主动向观察者推送改变的数据（存在的问题，主题对象不知道观察者需要哪些数据时，只能推送所有）
                        拉模型： pull 主题对象仅推送少量信息，通过传递subject引用给观察者，观察者自己选择需要获取的数据
                c.java中对观察者模式的支持
                        Observer接口：
                                update()方法，当被观察者对象的状态发生变化时。，被观察者对象的notifyObservers()方法就会调用这一方法
                        Observable 类：被观察者类都是java.util.Observable类的子类
                                setChanged()：被调用之后会设置一个内部标记变量，代表被观察者对象的状态发生了变化
                                notifyObservers()：这个方法被调用时，会调用所有登记过的观察者对象的update()方法，使这些观察者对象可以更新自己。
        2.
















