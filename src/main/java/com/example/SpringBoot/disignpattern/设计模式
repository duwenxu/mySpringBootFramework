1. UML类图中的关系：
        泛化关系(generalization):表现为 继承非抽象类    is a的关系
                                类的继承结构表现在UML中为：泛化(generalize)与实现(realize)
        实现关系(realize)：表现为 继承抽象类或实现接口
        聚合关系（aggregation）：表示 实体对象之间的关系，整体由部分构成    整体不存在了，部分依然存在(非强依赖)
        组合关系（composition）: 表示 实体对象之间的关系，整体由部分构成    整体不存在了，则部分也不存在(强依赖关系)
        关联关系（association）: 不同对象之间的一种静态关系，通常表现为 成员变量的形式
        依赖关系（dependency）: 表示一个对象在 运行期间 会用到另一个对象的关系
                               1.是一种临时性的关系    2.代码中表现为 类构造或其它方法的传入参数
2. 创建型模式：
        1. 简单工厂模式（静态工厂）：属于 类创建型模式
               a.角色     Factory：工厂角色                 工厂角色负责实现创建所有实例的内部逻辑
                          Product：抽象产品角色             抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口
                          ConcreteProduct：具体产品角色     具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例
               b.要点     当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节
               c.优点     对象的创建和对象的使用分离，将对象的创建交给专门的工厂类负责
                 缺点     工厂类不够灵活，增加新的具体产品需要修改工厂类的判断逻辑代码，而且产品较多时，工厂方法代码将会非常复杂
               d.使用场景   工厂类负责创建的对象比较少；客户端只知道传入工厂类的参数，对于如何创建对象不关心
        2. 工厂方法模式（工厂模式、虚拟其构造模式、多态工厂）：属于 类创建型模式
                a.角色    Product：抽象产品
                          ConcreteProduct：具体产品
                          Factory：抽象工厂                  定义创建产品对象的公共接口   将具体的产品类实例化操作延迟到工厂子类中完成
                          ConcreteFactory：具体工厂          负责生成具体的产品对象
                b.要点     在简单工厂模式的基础上对工厂类进行了多态化，所有的具体工厂类都需要实现抽象工厂类。
                           工厂角色和产品角色的多态性设计是工厂方法模式的关键
                c.优点     相比于简单工厂模式，加入新产品时只需要添加一个具体工厂和相对应的具体产品即可，而无需修改已有类。
                  缺点     添加新产品时，类的数量成对增加，一定程度上增加了系统的复杂性
                d.使用场景  将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定
        3.抽象工厂模式：（所有形式的工厂模式中最为抽象和最具一般性的一种形态）属于 对象创建型模式
                a.角色      Product：抽象产品                 为每种产品声明接口，在抽象产品中定义了产品的抽象业务方法
                           ConcreteProduct：具体产品          定义具体工厂生产的具体产品对象，实现抽象产品接口中定义的业务方法
                           Factory：抽象工厂                  声明生成抽象产品的方法
                           ConcreteFactory：具体工厂          实现了抽象工厂声明的生成抽象产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中
                b.要点     相比于工厂模式，增加了多个产品等级结构。
                           抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构
                                   产品等级结构：产品的继承结构    比如：抽象产品类---->具体产品类
                                   产品族：在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品
                c.优点      每次可以通过具体工厂类创建一个产品族中的多个对象，增加新的具体工厂和产品族很方便
                  缺点      增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类，对“开闭原则”的支持呈现倾斜性
                d.使用场景： 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节；系统中有多于一个的产品族，而每次只使用其中某一产品族
                            属于同一个产品族的产品将在一起使用；系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现
        4.建造者模式
                1.经典的Builder模式
                    4个角色：
                            Product：产品实例
                                    被构建的复杂对象，包含多个组成部件
                            Builder：定义了构建 Product 的抽象步骤 和 获取最终产品的方法 getProduct()
                                    抽象建造者为创建一个产品对象的各个部件指定抽象接口
                            ConcreteBuilder：Builder的具体实现类
                                    具体建造者实现了抽象建造者接口，实现各个部件的构造和装配方法，定义并明确它所创建的复杂对象，也可以提供一个方法返回创建好的复杂产品对象
                            Director：决定如何构建最终产品的算法. 包含一个负责组装的方法void Construct(Builder builder)，
                                      在这个方法中通过调用builder的方法，就可以设置builder，等设置完成后，就可以通过builder的 getProduct() 方法获得最终的产品
                                      该类的作用主要有两个：一方面它隔离了客户与生产过程；另一方面它负责控制产品的生成过程
                2.链式调用
                    builder模式的变种：
                            a. 省略了director 这个角色，将构建算法交给了client端
                            b. 将builder 写到了要构建的产品类里面，最后采用了链式调用
        5.prototype原型模式
                a. 角色：
                            抽象原型（Prototype）角色：规定了具体原型对象必须实现的接口（如果要提供深拷贝，则必须具有实现clone的规定）
                            具体原型（ConcretePrototype）：从抽象原型派生而来，是客户程序使用的对象，即被复制的对象，需要实现抽象原型角色所要求的接口
                b. 要点：
                            使用原型实例指定创建对象的种类，并且通过拷贝原型对象创建新的对象
                            相比于使用new创建新对象减少了构造函数的执行时间
                            实现方式：
                                    1. 实现 Cloneable 接口：Cloneable 接口与序列化接口的作用类似，它只是告诉虚拟机可以安全地在实现了这个接口的类上使用 clone() 方法。
                                    在 JVM 中，只有实现了 Cloneable 接口的类才可以被拷贝，否则会抛出 CloneNotSupportedException 异常
                                    2. 重写 Object 类中的 clone() 方法：在 Java 中，所有类的父类都是 Object 类，而 Object 类中有一个 clone() 方法，作用是返回对象的一个拷贝
                                    3. 在重写的 clone() 方法中调用 super.clone()：默认情况下，类不具备复制对象的能力，需要调用 super.clone() 来实现。
                            tips: 深拷贝与浅拷贝
                                    浅拷贝：只是拷贝对像本身，对象的所有变量都含有与原对象相同的值，但其所引用的对象仍然是原来的引用
                                    深拷贝：将要拷贝的对象所引用的对象也都拷贝了一次，彻底的拷贝
        6.对象池模式
                对于创建成本高的对象，采用object poll 对对象进行循环使用
                复用池中对象,消除创建对象、回收对象 所产生的内存开销、cpu开销以及(若跨网络)产生的网络开销。
                常见： 线程池、连接池等
                a. 角色：
                            ObjectPoll：对象池，用于保存和管理资源，持有对象并提供取/还等方法
                            object: 特定的资源类
                            client: 使用者类。   获取资源---使用----归还

3.行为型模式
        1. 观察者模式：定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新    对象行为型模式
                a.角色：
                        abstractSubject: 抽象主题(抽象被观察者)
                                        保持观察者的列表，有权增删观察者，发生变化时通知观察者
                        concreteSubject: 具体被观察者   实现具体的改变，并在发生改变时 通知具体的观察者
                        abstractObserver: 抽象观察者  定义update()接口，即收到主题通知后的操作
                        concreteObserver: 具体观察者  实现update()接口，保持与主题的改变相符合的状态
                b.推模型和拉模型
                        推模型： push 由subject主题对象主动向观察者推送改变的数据（存在的问题，主题对象不知道观察者需要哪些数据时，只能推送所有）
                        拉模型： pull 主题对象仅推送少量信息，通过传递subject引用给观察者，观察者自己选择需要获取的数据
                c.java中对观察者模式的支持
                        Observer接口：
                                update()方法，当被观察者对象的状态发生变化时。，被观察者对象的notifyObservers()方法就会调用这一方法
                        Observable 类：被观察者类都是java.util.Observable类的子类
                                setChanged()：被调用之后会设置一个内部标记变量，代表被观察者对象的状态发生了变化
                                notifyObservers()：这个方法被调用时，会调用所有登记过的观察者对象的update()方法，使这些观察者对象可以更新自己。
        2. 责任链模式：
                a. 角色：
                        abstractHandler: 抽象处理者      定义一个处理请求的接口
                                         如果需要还可以定义和返回对于下一个Handler的引用
                        concreteHandler: 具体处理者      该角色接收到请求后可以选择将请求处理掉或者是传递给下一个处理者
                b. 定义和理解：
                        责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。
                        发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织和分配责任
                c. 试用场景：
                        典型的：流程审批过程
                        应用：spring中的Filter,springSecurity 中的认证过程和权限管理过程，Netty中的pipeline是一个Handler的双向链表
        3. 策略模式：
                a. 定义：针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以互相替换。策略模式使得算法可以在不影响到客户端的情况下发生变化
                b. 角色：
                        context: 策略上下文类，持有一个strategy的引用
                        abstractStrategy: 抽象策略类，通常是抽象类或者接口(对于公有行为的实现应该试用抽象类)
                                          给出所有的具体策略类所需的接口
                        strategy: 具体策略类     包装了具体的算法和行为
                c. 要点：
                        策略模式的重心：不是如何实现算法，而是如何组织、调用这些算法，从而让程序结构更灵活，具有更好的维护性和扩展性
                        算法的平等性： 各个算法之间相互独立，地位平等，所以才可以 相互替换
                        运行时策略的唯一性： 每一个运行时刻只会有一种算法生效
                d.优缺点：
                        优点： 1.定义了策略的等级结构，避免重复代码  2.可以使用策略模式避免出现多重的 if-else
                        缺点： 1.客户端必须知道所有策略类，并主动选择使用哪种策略    2。 策略过多时会产生比较多的对象
        4. 模板方法模式
                a. 角色：
                        abstractTemplate: 抽象模板
                            1. 定义并实现了一个模板方法(这个模板方法一般是个具体方法)，给出了顶级的逻辑骨架，逻辑组成中的抽象操作将会推迟到子类中实现。
                            2. 定义了顶级逻辑的组成部分，是一个或多个抽象操作，以便让子类实现。这些抽象操作叫做基本操作
                        concreteTemplate: 具体模板
                            1. 实现父类所定义的一个或多个抽象方法，它们是一个顶级逻辑的组成步骤
                            2. 每个抽象模板角色可以有多个具体模板角色与之对应，每个具体模板角色都可以给出不同的实现来实现不同的顶级逻辑
                b. 要点：
                        关键：子类可以置换掉父类的可变部分，但是子类不可以改变模板方法所代表的顶级逻辑
                        模板中的方法：
                            1. 模板方法：定义在抽象类中用来表示顶层逻辑的方法，一个抽象类可以有多个模板方法
                            2. 基本方法：
                                抽象方法：abstract修饰,由抽象类声明，由具体子类实现
                                具体方法：一个具体方法由抽象类声明并实现，而子类并不实现或置换
                                钩子方法：一个钩子方法由抽象类声明并实现，而子类会加以扩展。通常抽象类给出的实现是一个空实现，作为方法的默认实现
                            tips:钩子方法(HookMethod)：常常由抽象类给出一个空实现作为此方法的默认实现，并可以由子类选择性的进行实现
                                钩子方法在父类中可以实现，可被子类重写，也可以是一个空实现
                                命名：钩子方法一般以 do开头，如 doGet()，doPost(),netty的doConnect()
                            目前的display工程的主要流程就是典型的模板方法模式
        5.迭代器模式
                a. 定义：迭代子模式可以顺序地访问一个聚集中的元素而不必暴露聚集的内部表象（internal representation）
                b. 角色：
                       抽象迭代子(Iterator)：定义出迭代子遍历元素所需的接口
                       具体迭代子(ConcreteIterator)：此角色实现了Iterator接口，并保持迭代过程中的游标未知
                       抽象聚集(Aggregate):给出创建迭代子（Iterator）对象的接口
                       具体聚集(ConcreteIterator): 实现了Aggregate接口,创建具体的迭代子实例
                       客户端对象：通过聚集类获取迭代子进行迭代

                c. 迭代器模式的意义在哪里?(相比于for循环直接迭代,为什么要使用迭代器模式创建迭代子进行迭代)
                       引入Iterator后可以将遍历与实现分离开来，即迭代子的遍历并不依赖于聚合对象的实现(单一职责+解耦)
                       具体的：迭代子对象和迭代模式会将迭代过程抽象化，将作为迭代消费者的客户端与迭代负责人的迭代子责任分隔开，使得两者可以独立地演化。
                               在聚集对象的种类发生变化，或者迭代的方法发生改变时，迭代子作为一个中介层可以吸收变化的因素，而避免修改客户端或者聚集本身。

                d. 静态迭代子和动态迭代子：
                        静态迭代子：由聚集对象创建，并持有聚集对象的一份快照（snapshot），在产生后这个快照的内容就不再变化
                                    (类似于COW类的原理，持有原对象的复制进行操作，线程安全)
                        动态迭代子：在迭代子被产生后，迭代子保持着对原聚集元素的引用,因此,任何对原聚集内容的修改都会在迭代子对象上反映出来
                                    Fail Fast:在一个动态迭代子的迭代过程中发生变化时，迭代过程会受到影响而变得不能自洽,就会向外抛出异常(ConcurrentModificationException)
                   外禀迭代子与内禀迭代子------
        6.状态模式

        7.命令模式




4. 结构型模式：
        1. 装饰器模式
                a.

        2. 适配器模式

        3. 桥接模式

        4. 代理模式
                a.定义： 代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。
                b.使用代理模式的好处：
                    1 .中介隔离   代理类通过实现与委托类相同的接口，可以使用户不直接访问委托对象
                    2 .更符合开闭原则，方便拓展增强。
                c. 有哪几种代理模式？
                    1 . 静态代理
                    2 . 动态代理(接口代理)
                    3 . CGLIB代理(子类代理，通过修改字节码文件)


















